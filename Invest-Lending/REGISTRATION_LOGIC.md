# Логика регистрации и хранения инвестора

Этот документ описывает рекомендуемую логику регистрации и состав данных инвестора для будущего личного кабинета, а также подготовительные действия в сервисах. Код и конфигурация проекта не изменялись.

## Каналы регистрации

Регистрация должна поддерживать 2 способа:
- Email (логин по email + пароль)
- Telegram

## Общий принцип

1. Пользователь выбирает способ регистрации.
2. Система получает или запрашивает базовые данные.
3. Генерируется уникальный `investorId` (ключ инвестора).
4. `investorId` и профиль инвестора сохраняются в БД.
5. Возвращается успешная регистрация и `investorId` для доступа в личный кабинет.

## Генерация `investorId`

Требования:
- Уникальность (гарантировать, что ключ не повторится).
- Непредсказуемость (не использовать последовательные значения).
- Удобный формат (например, 16–24 символа).

Рекомендуемые варианты:
- UUID v4 (`uuid`) — быстро и безопасно.
- ULID — сортируемый по времени.
- Кастомный ID на базе `crypto.randomUUID()` + префикс `inv_`.

Пример формата: `inv_01HV9Q9Z7F7V2G2YFQ2T9C2D6P`

## Данные инвестора (минимальный набор)

Обязательные поля:
- `investorId`
- `createdAt`
- `authProvider` (email | telegram)
- `status` (active | pending | blocked)

Рекомендуемые поля:
- `name`
- `email`
- `phone`
- `country`
- `passwordHash` (только для email-регистрации)
- `telegramId` (для Telegram)
- `telegramId` (для Telegram)
- `lastLoginAt`
- `kycStatus` (not_started | in_review | approved | rejected)
- `marketingSource`
- `referralCode`

Важно: пароли хранить только в виде хэша (например, `bcrypt`). Хранение паролей в открытом виде недопустимо.

## Предварительные действия в сервисах

Ниже перечислены обязательные действия до начала разработки, чтобы регистрация работала корректно.

### 1) Email (SMTP/почтовый провайдер)

Нужно:
- Выбрать почтовый сервис (SendGrid, Mailgun, Amazon SES, Postmark и т.п.).
- Создать домен отправителя и подтвердить его (DNS записи).
- Получить SMTP/HTTP API ключ.
- Настроить адрес отправителя и шаблоны писем (подтверждение email, восстановление).

Что получить:
- SMTP/HTTP API key.
- Подтвержденный домен отправителя.
- Конфигурацию отправителя (from name, from email).

### 2) Telegram

Нужно:
- Создать бота через BotFather.
- Получить `bot_token`.
- Настроить Telegram Login Widget (если используется web‑авторизация).
- Добавить разрешенные домены/redirect (для Login Widget).

Что получить:
- `bot_token`.
- Данные/настройки для Telegram Login (домен, hash‑проверка).

### 3) База данных

Нужно:
- Спроектировать таблицу/коллекцию `investors`.
- Создать уникальные индексы по `email`, `telegramId`.
- Подготовить таблицы/коллекции для логов авторизации (опционально).

Что получить:
- Структуру БД и миграции.
- Уникальные индексы и ограничения.

### 6) Переменные окружения

Нужно:
- Собрать ключи/секреты в `.env` или секрет‑хранилище.

Пример:
```
SMTP_API_KEY=...
SMTP_FROM_EMAIL=...
SMTP_FROM_NAME=...
TELEGRAM_BOT_TOKEN=...
GOOGLE_CLIENT_ID=...
GOOGLE_CLIENT_SECRET=...
FACEBOOK_APP_ID=...
FACEBOOK_APP_SECRET=...
JWT_SECRET=...
```

## Логика регистрации по каналам

### 1) Email

1. Пользователь вводит имя, email, пароль (и, при необходимости, телефон и страну).
2. Проверка уникальности email.
3. Хэширование пароля.
4. Генерация `investorId`.
5. Сохранение записи инвестора в БД.
6. Опционально: подтверждение email (OTP/ссылка).

### 2) Telegram

1. Пользователь проходит авторизацию через Telegram (OAuth/бот).
2. Система получает `telegramId`, имя, username (если есть).
3. Генерация `investorId`.
4. Сохранение записи инвестора в БД.
5. Если email не получен — предложить добавить позже в личном кабинете.

### 3) Google

1. Пользователь проходит Google OAuth.
2. Получаем `googleId`, email, имя, аватар (если нужно).
3. Генерация `investorId`.
4. Сохранение записи инвестора в БД.

### 4) Facebook

1. Пользователь проходит Facebook OAuth.
2. Получаем `facebookId`, имя, email (если разрешено).
3. Генерация `investorId`.
4. Сохранение записи инвестора в БД.

## Проверка уникальности

- Уникальность должна проверяться по:
  - `email` (если есть)
  - `telegramId`
  - `googleId`
  - `facebookId`

Если пользователь уже существует:
- Возвращать его `investorId`.
- Предлагать вход вместо регистрации.

## Пример схемы коллекции/таблицы `investors`

Поля (условный JSON):
```
{
  "investorId": "inv_01HV9Q9Z7F7V2G2YFQ2T9C2D6P",
  "authProvider": "google",
  "name": "Ivan Petrov",
  "email": "ivan@example.com",
  "phone": "+7 900 000-00-00",
  "country": "RU",
  "passwordHash": null,
  "telegramId": null,
  "googleId": "1092384923849238",
  "facebookId": null,
  "status": "active",
  "kycStatus": "not_started",
  "createdAt": "2026-01-22T12:00:00Z",
  "lastLoginAt": "2026-01-22T12:00:00Z"
}
```

## Потоки регистрации (кратко)

1. **Email** → verify email → create record → return `investorId`
2. **Telegram** → create record → return `investorId`
3. **Google** → create record → return `investorId`
4. **Facebook** → create record → return `investorId`

## Важно учесть

- ID инвестора должен использоваться как ключ для личного кабинета.
- Все персональные данные хранить по принципу минимально необходимого.
- Часть данных можно дособрать после регистрации (профиль/анкета).
- Логи аудита регистрации и входов полезны для безопасности.

